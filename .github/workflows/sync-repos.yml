name: Sync Forked Repositories

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

env:
  ORG_NAME: "vulnerable-code"

jobs:
  list-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      repository-projects: write
      pull-requests: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v6
    
    - name: Install dependencies
      run: |
        sudo apt update
        sudo apt install jq gh parallel -y
  
    - name: Login to GitHub
      run: |
        echo "${{ secrets.WRITE_TOKEN }}" | gh auth login --with-token

    - name: List all repositories in the organization and sync them in parallel
      run: |
        # List all forks in the organization
        forks=$(gh api orgs/$ORG_NAME/repos --jq '.[] | select(.fork==true) | .full_name' --paginate)
        
        # Function to sync a repository and capture failures
        sync_repo() {
          fork=$1
          echo "Updating $fork"
          if ! gh repo sync $fork --force; then
            echo "$fork failed" >> failed_repos.log
            return 1
          fi
        }

        export -f sync_repo

        # Run sync for each fork in parallel and ensure the job fails if any fail
        echo "$forks" | parallel -j 2 sync_repo {}

        # Check if any sync failed
        if [ -f failed_repos.log ]; then
          echo "Some repositories failed to sync:"
          cat failed_repos.log
          exit 1
        fi

    - name: Disable actions for all except whitelisted workflows
      run: |
        # List all repositories in the organization
        repos=$(gh api orgs/$ORG_NAME/repos --jq '.[] | .full_name' --paginate)

        disable_workflow_with_retry() {
          repo=$1
          workflow_id=$2
          workflow_name=$3
          workflow_path=$4

          max_attempts=4
          attempt=1
          sleep_seconds=5

          while [ $attempt -le $max_attempts ]; do
            set +e
            OUTPUT=$(gh api repos/$repo/actions/workflows/$workflow_id/disable -X PUT 2>&1)
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -eq 0 ]; then
              return 0
            fi

            # If it's already disabled, treat as success.
            if echo "$OUTPUT" | grep -q "Unable to disable a workflow that is not active"; then
              return 0
            fi

            # Rate limits: stop processing (like the sync workflow in the other repo).
            if echo "$OUTPUT" | grep -qi "rate limit" || echo "$OUTPUT" | grep -qi "API rate limit exceeded" || echo "$OUTPUT" | grep -qi "secondary rate limit"; then
              echo "Rate limit reached while disabling workflow $workflow_id in $repo"
              echo "$repo $workflow_id $workflow_name $workflow_path rate_limited" >> disable_rate_limited_workflows.log
              return 2
            fi

            # Retry on 422 with backoff.
            if echo "$OUTPUT" | grep -q "HTTP 422"; then
              echo "HTTP 422 when disabling workflow $workflow_id in $repo (attempt $attempt/$max_attempts). Sleeping ${sleep_seconds}s and retrying..."
              sleep "$sleep_seconds"
              attempt=$((attempt + 1))
              sleep_seconds=$((sleep_seconds * 2))
              continue
            fi

            echo "$repo $workflow_id $workflow_name $workflow_path failed: $OUTPUT" >> disable_failed_workflows.log
            return 0
          done

          # 422 is typically permanent for some GitHub-managed workflows; record and continue.
          echo "$repo $workflow_id $workflow_name $workflow_path unprocessable (HTTP 422)" >> disable_422_workflows.log
          return 0
        }

        # Process repositories one by one, stopping on rate limit.
        while IFS= read -r repo; do
          [ -z "$repo" ] && continue

          set +e
          workflows=$(gh api repos/$repo/actions/workflows --paginate --jq '
            .workflows[] |
            select(
              (.state == "active") and
              (
                (.name != "CodeQL" or .path != "dynamic/github-code-scanning/codeql") and
                (.name != "Sync Forked Repositories" or .path != ".github/workflows/sync-repos.yml") and
                (.name != "Dependabot Updates" or .path != "dynamic/dependabot/dependabot-updates")
              )
            ) | "\(.id)\t\(.name)\t\(.path)"')
          workflows_exit_code=$?
          set -e

          if [ $workflows_exit_code -ne 0 ]; then
            echo "$repo workflows_list_failed" >> disable_failed_workflows.log
            continue
          fi

          while IFS=$'\t' read -r workflow_id workflow_name workflow_path; do
            [ -z "$workflow_id" ] && continue
            echo "Disabling workflow $workflow_id in $repo"
            set +e
            disable_workflow_with_retry "$repo" "$workflow_id" "$workflow_name" "$workflow_path"
            RESULT=$?
            set -e
            if [ $RESULT -eq 2 ]; then
              echo "Rate limit reached, stopping disable process"
              break 2
            fi
          done <<< "$workflows"
        done <<< "$repos"

        if [ -f disable_failed_workflows.log ]; then
          echo "Some workflows failed to disable:"
          cat disable_failed_workflows.log
        fi

        if [ -f disable_422_workflows.log ]; then
          echo "Some workflows could not be disabled (HTTP 422):"
          cat disable_422_workflows.log
        fi

        if [ -f disable_rate_limited_workflows.log ]; then
          echo "Rate limit reached while disabling workflows:"
          cat disable_rate_limited_workflows.log
        fi

    - name: Save datetime of the last run
      run: date '+%Y-%m-%d %H:%M:%S' > sync.log
    
    - name: Commit and push sync log
      run: |
        DATE=$(date '+%Y-%m-%d %H:%M:%S')
        echo $DATE > sync.log
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@github.com"
        git add sync.log
        git commit -m "Update sync log with the latest run date and time: $DATE"
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.WRITE_TOKEN }}
